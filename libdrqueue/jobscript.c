//
// Copyright (C) 2001,2002,2003,2004,2005,2006 Jorge Daza Garcia-Blanes
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
// USA
//
// $Id$
//

#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>
#include "libdrqueue.h"
#include "jobscript.h"

struct jobscript_info *jobscript_new (jobscript_type type,char filename[PATH_MAX]) {
  FILE *f = NULL;

  if ( type != JOBSCRIPT_TCSH ) {
    fprintf (stderr,"ERROR: Job type requested unknown (%i)\n",type);
    fprintf (stderr,"ERROR: %s\n",drerrno_str());
    return NULL;
  }

  if ((f = fopen (filename, "a")) == NULL) {
    drerrno = DRE_COULDNOTCREATE;
    fprintf (stderr,"Could not create script at: %s\n",filename);
    fprintf (stderr,"ERROR: %s\n",drerrno_str());
    return NULL;
  }

  fchmod (fileno(f),0777);

  struct jobscript_info *jsi = (struct jobscript_info*) malloc (sizeof (struct jobscript_info));
  jsi->type = type;
  jsi->file = f;
  strncpy(jsi->filename,filename,PATH_MAX);

  return jsi;
}

int jobscript_check_pointer (struct jobscript_info *ji) {
  if ( ji == NULL ) {
    fprintf (stderr,"ERROR: jobscript: invalid NULL pointer\n");
    return 0;
  }

  return 1;
}

int jobscript_write_heading (struct jobscript_info *ji) {
  int rv;
  if ( (rv = jobscript_check_pointer (ji)) == 0 ) {
    return rv;
  }

  switch (ji->type) {
  case JOBSCRIPT_TCSH:
    return jobscript_tcsh_write_heading (ji);
    break;
  }
  
  // TODO: ERROR bla bla
  return 0;
}

int jobscript_set_variable_int (struct jobscript_info *ji,char name[JS_MAX_VAR_NAME],int64_t value) {
  char str_value[JS_MAX_VAR_VALUE];
  snprintf (str_value,JS_MAX_VAR_VALUE,"%lli",value);
  return jobscript_set_variable (ji,name,str_value);
}

int jobscript_set_variable (struct jobscript_info *ji,char name[JS_MAX_VAR_NAME],char value[JS_MAX_VAR_VALUE]) {

  int rv;
  if ((rv = jobscript_check_pointer (ji)) == 0 ) {
    return rv;
  }

  switch (ji->type) {
  case JOBSCRIPT_TCSH:
    return jobscript_tcsh_set_variable (ji,name,value);
    break;
  }

  // TODO: ERROR bla bla
  return 0;
}

int jobscript_tcsh_check_pointer (struct jobscript_info *ji) {
  if ( ji == NULL ) {
    fprintf (stderr,"ERROR: tcsh jobscript: invalid NULL pointer\n");
    return 0;
  } else if ( ji->type != JOBSCRIPT_TCSH ) {
    fprintf (stderr,"ERROR: tcsh jobscript: pointer indicates not a tcsh script file\n");
    return 0;
  }

  return 1;
}

int jobscript_tcsh_write_heading (struct jobscript_info *ji) {
  int rv;
  if ( (rv = jobscript_tcsh_check_pointer (ji)) == 0 ) {
    return rv;
  }
  fprintf(ji->file,"#!/bin/tcsh\n");
  fprintf(ji->file,"### GENERATED BY JOBSCRIPT TOOLS\n");
  fprintf(ji->file,"# generated using the jobscript tools from libdrqueue\n");
  fprintf(ji->file,"### END OF HEADING\n");
  return 1;
}

int jobscript_tcsh_set_variable (struct jobscript_info *ji,char name[JS_MAX_VAR_NAME],char value[JS_MAX_VAR_VALUE]) {
  int rv;
  if ( (rv = jobscript_tcsh_check_pointer (ji)) == 0 ) {
    return rv;
  }
  // TODO: correct name of variable
  fprintf (ji->file,"\n## tcsh variable set by jobscript tools\n");
  fprintf (ji->file,"set %s=\"%s\"\n",name,value);
  return 0;
}
