<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>Ruby/Python Documentation</title>
</head>

<body bgcolor="#ffffff">
<h1>Ruby/Python ドキュメント</h1>

<h2>目次</h2>
<ul>
  <li><a href="#intro">はじめに</a>
      <ul>
	<li><a href="#whats">Ruby/Python とは?</a>
	<li><a href="#simple">簡単な例</a>
	<!--<li><a href="#term">用語</a>-->
      </ul>
  <li><a href="#from_ruby">Ruby から Python オブジェクトを操作する</a>
      <ul>
	<li><a href="#require">Ruby/Pythonのロード</a>
	<li><a href="#eval"><code>eval</code> と <code>exec</code></a>
	<li><a href="#method">メソッド呼び出し</a>
	<li><a href="#module">モジュール</a>
	<li><a href="#class">クラスとタイプ</a>
	<li><a href="#convert">オブジェクトの変換</a>
      </ul>
  <li><a href="#ref">リファレンス</a>
</ul>

<hr><a name="intro">
<h2>はじめに</h2></a>

<a name="whats">
<h3>Ruby/Python とは?</h3></a>

<p>Ruby/PythonはRubyにPythonインタプリタをライブラリとして埋め込んでしま
う、Ruby の拡張ライブラリです。Ruby/Python を使うと、Ruby スクリプトから 
Python 用に作られたライブラリを利用することができます。

<p>Ruby/Python は二つの言語を出来る限り透過的に繋げるように作られていま
す。したがって、Python のライブラリを利用するのに、特別な配慮や面倒なコー
ディングはほとんど必要ありません。Ruby 用に作られたライブラリを利用する
のとほとんど変わらない感覚で使用できます。

<a name="simple">
<h3>簡単な例</h3></a>

<p>まず簡単な例としてftplibを使用して、FTPサーバにアクセスするRubyスクリ
プトを見てみましょう。ftplib自体はRubyにもPythonにもそれぞれの言語用のも
のが標準で添付されています。したがって、Ruby/Pythonを使ってPythonの
ftplibを使うこと自体には実用的な意味はありません。でも、比較のためにはもっ
てこいです。

<p>まずはRuby用にRubyで書かれたftplibを使うスクリプトです。

<blockquote><pre>
require 'ftplib'

ftp = FTP.open('ftp.netlab.co.jp')
ftp.login
ftp.chdir('pub/lang/ruby')
puts ftp.dir
ftp.quit
</pre></blockquote>

Rubyを使うと非常に簡単に書けますね。それでは次は、同じことをRuby/Python
を用いてPythonのftplibを使って書いたスクリプトです。

<blockquote><pre>
require 'python'
require 'python/ftplib'

ftp = Py::Ftplib::FTP.new('ftp.netlab.co.jp')
ftp.login
ftp.cwd('pub/lang/ruby')
ftp.dir
ftp.quit
</pre></blockquote>

<p>最初の例と比べて見てください。どうですか？それほど違いはありませんよ
ね。でもこの後者の例はPython用に書かれたライブラリを使っているのです。

<p>大きく違う部分は冒頭の<code>require</code>でライブラリをロードする部
分と、<code>FTP</code>クラスの名前を指定している部分です。それ以外の部分
はメソッド名が若干異なるだけです。Rubyを良く知っている人なら、これだけで
Ruby/Pythonをどうやって使うのか大体分かってしまうと思います。このように
Ruby/PythonはPython用に書かれたライブラリを、あたかもそれがRuby用に書か
れたライブラリであるかのように使えるようにする拡張ライブラリなのです。

<!--
<a name="term">
<h3>用語</h3></a>

<p>このドキュメントではRubyとPythonという2つの言語に関することが書かれて
います。2つの言語は似通った概念を持っている部分もあるので、混乱を避ける
ため、幾つかの用語を定義しておきます。

<dl compact>
  <dt>Ruby/Python <dd>この拡張ライブラリそのもの
  <dt>Rubyオブジェクト
  <dd>Rubyインタプリタ上に存在するRubyのオブジェクト
  <dt>Pythonオブジェクト
  <dd>Pythonインタプリタ上に存在するPythonのオブジェクト
  <dt>Rubyモジュール <dd>Ruby上で定義された<code>Module</code>
  <dt>Pythonモジュール <dd>Python上で定義された、Python用のモジュール
  <dt>Rubyクラス <dd>Ruby上で定義された<code>Class</code>
  <dt>Pythonクラス <dd>Python上で定義されたクラス
  <dt>Pythonタイプ <dd>Python上で定義されたタイプ。(注: Pythonではタイプ
      とクラスは別々のものです。) 
</dl>
-->

<hr><a name="from_ruby">
<h2>Ruby から Python オブジェクトを操作する</h2></a>

Ruby/Python を使って、Ruby スクリプトから Python のモジュールやオブジェ
クトを操作する方法について説明します。

<a name="require">
<h3>Ruby/Pythonのロード</h3></a>

<blockquote><pre>
require 'python'
</pre></blockquote>

<p>Ruby/Pythonを使う場合には、まず最初にRuby/Pythonライブラリをロードし
ます。Ruby/Python自体は<code>'python'</code>という名前のライブラリです。
これでRuby/Pythonを使用できる状態になります。

Ruby/Pythonライブラリがロードされると (<code>Object</code> クラス直下に)
<code>Py</code> という名前のモジュールが作られます。Ruby/Python の機能は、
基本的にはこの <code>Py</code> モジュールの下のモジュールやクラス、モジュー
ル関数として提供されます。

<a name="eval">
<h3><code>eval</code> と <code>exec</code></h3></a>

<blockquote><pre>
Py.eval(<var>PythonExpression</var>)
Py.exec(<var>PythonStatement</var>)
</pre></blockquote>

Pythonの機能を呼び出す最も単純な方法は<code>Py</code>モジュールのモジュー
ル関数である<code>eval</code>と<code>exec</code>を使う方法です。これらは
Pythonの組み込み関数evalとexec文に相当するものです。<code>Py.eval</code>
はPythonの式を評価し、その式の値を返します。<code>Py.exec</code>はPython
の文を実行します。

<p>例:
<blockquote><pre>
list = Py.eval('[1, 2, 3]')     # Pythonのリストオブジェクトを返す。
Py.exec('print "hello world"')  # "hello world"を表示する。
</pre></blockquote>

<a name="method">
<h3>メソッド呼び出し</h3></a>

<blockquote><pre>
obj.<var>method</var>(...)
obj.<var>method?</var>(...)  # 戻り値はtrueかfalse
</pre></blockquote>

Pythonオブジェクトに対しては通常のメソッド呼び出しができます。メソッド名
の後に<code>'?'</code>を付けて呼び出した場合、その戻り値をPythonの真偽値
として判定した値を返します。この記法が必要なのは、Pythonの真偽値とRubyの
真偽値の間に単純な対応関係がないからです。したがって、戻り値として真偽値
を期待する場合は必ず<code>'?'</code>を付けて下さい。(Pythonでは真偽値を
表す特別な値は存在せず、<code>None</code>や<code>0</code>や空リストなど
が偽を表し、それ以外は真を表します。多くの場合、Pythonでは偽を表すのには
<code>0</code>が使われるようですが、<code>0</code>はRubyでは真です。)

<p>例:
<blockquote><pre>
dict = Py.eval('{"One": 1, "Two": 2}') # Pythonの辞書(ハッシュ)
dict.keys                              # ["One", "Two"]
dict["Two"]                            # 2
dict.has_key("Three")                  # 0 (Rubyでは真)
dict.has_key?("Three")                 # false
</pre></blockquote>

<h4>キーワード引数</h4>

<blockquote><pre>
obj.<var>method</var>([...,] Py::AS_KEYWORD, <var>key1</var> => <var>val1</var>, <var>key2</var> => <var>val2</var>, ...)
obj.<var>method</var>([...,] Py::KW, <var>key1</var> => <var>val1</var>, <var>key2</var> => <var>val2</var>, ...)
</pre></blockquote>

<p>Pythonのメソッドにはキーワード引数を渡すことができます。しかし、現時
点ではRubyはキーワード引数をサポートしていません。そこで、Ruby/Pythonで
は上記のような呼び出し方をすることにします。この方法では
<code>Py::AS_KEYWORD</code>という定数を使います。(略記法として
<code>Py::KW</code>という名前もあります。) 引数リストの中に
<code>Py::AS_KEYWORD</code>がある場合には、それ以降の引数はキーワード引
数を含むハッシュであると解釈されます。各キーワードの名前は文字列かシンボ
ル値で指定します。

<p>例:
<blockquote><pre>
ftp = Py::Ftplib::FTP.new
ftp.connect(Py::AS_KEYWORD, 'host' => 'ftp.netlab.co.jp') # 文字列で指定する場合
ftp.login(Py::KW, :user => 'ftp', :passwd => 'address')   # シンボル値で指定する場合
</pre></blockquote>

<h4>ブロック付きメソッド呼び出し</h4>

<blockquote><pre>
obj.<var>method</var>(...) {|arg| ...}
</pre></blockquote>

Pythonのメソッドを呼ぶ時にブロックを与えると、そのブロックから
<code>Proc</code>オブジェクトが生成され、最後の引数として渡されます。し
たがって上の式は以下の式とほぼ等価です。

<blockquote><pre>
obj.<var>method</var>(..., Proc.new{|arg| ...})
</pre></blockquote>

<a name="module">
<h3>モジュール</h3></a>

<h4>Pythonモジュールをimportする</h4></a>

<blockquote><pre>
require 'python/<var>module</var>'
</pre></blockquote>

<p>Ruby/Pythonライブラリは組み込み関数の <code>require</code> を置き換え
ます。置き換えられた <code>require</code> は、<code>'python/'</code>で始
まるライブラリ名が引数として渡されると、特別な動作をします。(それ以外の
場合は通常の<code>require</code>と同じ。) <code>'python/'</code>で始まる
ライブラリ名が渡されると、スラッシュの後に指定された名前の Python モジュー
ルを import します。これは Python スクリプト上で以下の文を実行することに
相当します。

<blockquote><pre>
import <var>module</var>
</pre></blockquote>

<p>importされたPythonモジュールは、Rubyスクリプトからは<code>Py</code>モ
ジュールの下で定義されているRubyモジュールとして見えます。Pythonモジュー
ルの名前が小文字で始まる場合は、先頭の文字を大文字にした名前で定義されま
す。また<code>Py</code>モジュールに対する属性参照によってそのモジュール
にアクセスすることも出来ます。

<p>例: Python の sys モジュールを参照する方法
<blockquote><pre>
require 'python'      # Pyが定義される
require 'python/sys'  # Py::Sysが定義される
Py::Sys               # 定数による参照
Py.sys                # Pyモジュールに対する属性参照。Py::Sysと同じ
</pre></blockquote>

<h4>Pythonモジュールの機能を呼び出す</h4>

<p>Pythonモジュールで定義されている関数や属性は、モジュール関数として呼
び出すことができます。

<p>例:
<blockquote><pre>
require 'python/math'  # Py::Mathが定義される
Py::Math.sqrt(2)       # 1.41421
Py::Math.pi            # 3.14159
</pre></blockquote>

<a name="class">
<h3>クラスとタイプ</h3></a>

<h4>Rubyクラスへのマッピング</h4>

<p>Pythonのクラスとタイプに対しては、それと対応するRubyクラスが自動的に
定義されます。こららのクラスは全て<code>Py::Object</code>クラスのサブク
ラスとして定義されます。つまり全てのPythonオブジェクトは
<code>Py::Object</code>クラスに属しているように見えます。

<p>例:
<blockquote><pre>
list = Py.eval('[1, 2, 3]')  # Pythonリストタイプのオブジェクト
list.type                    # Py::Types::ListTypeクラス
list.is_a?(Py::Object)       # true
</pre></blockquote>

<h4>クラスインスタンスの生成</h4>

<p>各Pythonクラスに対応するRubyクラスに定義されているクラスメソッド
<code>new</code>を呼び出すことでクラスのインスタンスを生成できます。
<code>new</code>に渡された引数は、Pythonのインスタンス生成の引数として使
われます。

<p>例:
<blockquote><pre>
require 'python/ftplib'
ftp = Py::Ftplib::FTP.new('ftp.netlab.co.jp')
# 以下のようなPythonのインスタンス生成に相当
# ftplib.FTP('ftp.netlab.co.jp')
</pre></blockquote>

<a name="convert">
<h3>オブジェクトの変換</h3></a>

<p>オブジェクトはメソッド呼び出しの引数として渡される時に、RubyとPython
の間を行き来することがあります。その際に、オブジェクトは移動先の言語のオ
ブジェクトに自動的に変換されます。またメソッド呼び出しの戻り値として戻る
時には逆の変換が行われます。

<h4>値渡しされるオブジェクト</h4>

<p>以下のオブジェクトは、それぞれの言語のネイティブなオブジェクトに変換
されます。つまり値渡しになります。

<center>
<table border>
<tr><th>Rubyオブジェクト</th><th>Pythonオブジェクト</th><th>備考</th>
<tr><td><code>nil</code></td><td><code>None</code></td>
<tr><td><code>true</code></td><td><code>1</code></td><td>(1)</td>
<tr><td><code>false</code></td><td><code>0</code></td><td>(1)</td>
<tr><td><code>Stringのインスタンス</code></td><td>Python文字列</td>
<tr><td><code>Integerのインスタンス</code></td>
    <td>Plain Intger および Long Integer</td>
<tr><td><code>Floatのインスタンス</code></td>
    <td>Floating Point Number</td>
</table>
</center>
備考:<dl compact>
<dt>(1)
<dd>この変換はRubyからPythonへの変換の場合にのみ自動的に行われます。
    PythonからRubyへ変換する場合には、0や1は単に<code>Integer</code>に
    変換されます。
</dl>

<h4>Pythonモジュール、クラス、タイプ</h4>

<p>Pythonのモジュール、クラス、タイプは、それと対応するRubyの
<code>Module</code>や<code>Class</code>が自動的に定義されます。したがっ
てこれらは、その対応するオブジェクト同士で相互に変換されます。

<h4>参照渡しされるオブジェクト</h4>

<p>上記以外のオブジェクトは参照渡しされます。

<p>PythonオブジェクトがRuby側に参照渡しされる時は、Py::Objectのサブクラ
スのインスタンスに変換されます。このオブジェクトはPythonオブジェクトへの
参照を保持するオブジェクトで、PythonオブジェクトへのProxyとして機能しま
す。このProxyオブジェクトにメッセージを送ると、対応するPythonオブジェク
トへメッセージが転送されます。

<p>RubyオブジェクトをPython側へ参照渡しする時は、Python側からは拡張タイ
プのオブジェクトとして見えます。このオブジェクトもRubyオブジェクトへの参
照を保持するProxyとして機能し、メッセージの転送を行います。

<hr><a name="ref">
<h2>リファレンス</h2></a>

モジュール
<ul>
  <li><a href="Py.html">Py</a><br>
  <li><a href="Sequence.html">Py::Sequence</a><br>
  <li><a href="Mapping.html">Py::Mapping</a><br>
</ul>

クラス
<ul>
  <li><a href="Object.html">Py::Object</a>
</ul>

<hr>
<address>fukusima@goto.info.waseda.ac.jp</address>
<!-- hhmts start -->
Last modified: Sun May  9 21:47:25 JST 1999
<!-- hhmts end -->
</body> </html>
